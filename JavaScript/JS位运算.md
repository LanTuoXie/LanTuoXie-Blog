##JS位运算符

### 整数

- 有符号整数：允许使用正数和负数，第32位作为符号位，前31位才是存储位
- 无符号整数：只允许用正数

![图片](http://www.w3school.com.cn/i/ct_js_integer_binary_signed_32bits.gif)

- 如果用`n`代表位   
- `位数 = 2^n-1`
- 由于位数(1、2、4、8、16...)中只有第一位`| 1 |`是奇数，所以可以根据第一位`| 1 |`的数值判断一个数值是奇数还是偶数
- `num % 2`运算本质就是取的`| 1 |`的值，如果是1就是奇数，是0就是偶数

### 补码和反码

- 确定该数字的非负版本的二级制表示`const getBinary = num => num.toString(2)`
- 求得二进制反码，反码就是把原来的二进制1,0互换。即要把 0 替换为 1，把 1 替换为 0
- 在二进制反码上加1

### 位运算NOT`~`

`~`的处理过程

- 把运算数转换成32位数字
- 把二进制数转换成它的二进制反码
- 把二进制数转换成浮点数

实质上是对数字求负，然后减1`-num - 1`

### 位运算AND `&` 和 OR `|` 和 XOR `^`

- `&`每个数字中的数位对齐，位对位进行与运算
- `|`每个数字中的数位对齐，位对位进行或运算
- `^`每个数字中的数位对齐，位对位进行异或运算
- JS中的二进制有32位，所以要进行32次运算

### 有符号移动`<<< 、>>>`和无符号移动 `<<、>>`

- 有符号移动在移动的时候不会移动符号位，即不会移动第32位，而无符号移动会移动符号位
- 左移`<<`相等于乘于2，而右移`>>`相当于除于2

### 遍历二进制位结构

由于二进制的结构是`| 16 | 8 | 4 | 2 | 1 |`这种结构，位数是从右边开始的，我们遍历要从右边开始

```js
function eachBit(num, callback) {
  while (num) {
    num >>= 1
  }
}
```

- 这里使用了右移的方式遍历，当num为0的时候就停止遍历如`10 = (0,1,0,1,0)`，最靠近左边的`1`在第四位`2^4-1 = 8`，`| 8 |`，所以遍历了4次
- 我们要把`遍历的次数`和`当前的位数`以及`被右移出去的值(0或1)`传递给`callback`

```js
function eachBit(num, callback) {
  let i = 0
  let bitNum = 0
  while (num) {
    // 奇偶位或第一位的值，也即即将被右移出去的值
    const value = num % 2
    
    // 位数 = 2^i
    bitNum = Math.pow(2, i)
    
    callback && callback(value, i, bitNum)
    
    // 右移1位
    num >>= 1
    i++
  }
}
```

### 使用遍历体实现字符串repeat函数

```js
function repeat(str, n) {
  let res = ''
  eachBit(n, v => {
    if (v === 1) {
      res += str
    }
    if (n > 1) {
      str += str
    }
  })
  return res
}
```

- 实现思路：由于字符串要重复的内容是一样的，为了减少遍历次数，采用了`eachBit`，比如`n = 10`那么二进制`'1010'`只需遍历四次
- 注意上面的1对应的数字，第四位1对应`| 8 |`，第二位1对应`| 2 |`
- `str += str`就是一直迭代，重复次数是`2^n`（n是遍历的次数）
- `v === 1`的时候也即`| 2 |`，这时候是`str + str`2个重复的`str`，`| 8 |`是8个重复的`str`
- 也即`str`的重复次数是对应`| 2 |`和`| 8 |`的，刚好重复10次
- `n > 1`是n等于1，没有必要再执行迭代了，只会遍历一次，且v必等于1，后面没有必要执行了