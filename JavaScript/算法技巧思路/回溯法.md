# 回溯法(解决搜索问题的路径)

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

解决一个回溯问题，实际上就是一个决策树遍历过程。

1. 路径：也就是已经做出的选择。
2. 选择列表：也就是你当前可以做的选择。
3. 结束条件：也就是到达决策树底层，无法再做选择的条件。

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

## 常见搜索方案

- **深度优先搜索(DFS)**：先朝着一个方向搜到底，再回溯至上个节点，沿另一个方向搜索。
- **剪枝**：在搜索中，遇到这条路不可能和目标字符串匹配成功的情况，则应立即返回，称之为可行性剪枝。
- **迷宫的常见解法**：【暴力递归上下左右4个方向】。
- **广度优先搜索(BFS)**：按平推的方式向前搜索，通常利用队列实现广度优先遍历。
- **二叉树是只有2个方向的迷宫**：可以使用迷宫的方式遍历和克隆二叉树。

## 【DFS 和 BFS的区别】

- DFS：指深度优先搜索，DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。【`left || right || top || bottom`】**不用从头再来一遍，在上次成功的节点继续搜索**，关键字：**和动态规划很像，很依赖之前搜索的结果**。在某种场景下，【DFS最大的缺点是遍历不全，最大的优点是避免不必要的遍历】。非常适合查找唯一最优解的场景。**深度一词主要体现在遍历的方向【纵向性】**。【经典案例：唯一出口迷宫。】
- BFS：指广度优先搜索，DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。**通常通过队列实现**。适合场景：【一个问题有多个解，你需要收集这些解】。**广度一词主要体现在遍历的方向【水平性】**。【经典案例：**树的层次遍历**。】

## 遍历二叉树

- 前序遍历：`【根节点 | 左子树 | 右子树】`
- 中序遍历：`【左子树 | 根节点 | 右子树】`
- 后序遍历：`【左子树 | 右子树 | 根节点】`
- 层次遍历：队列 + 广度优先搜索

## 注意事项

- 递归遍历的时候需要注意，【避免重复访问】
- 避免重复访问的方法有2种，一个是用map缓存之前访问过的，或者先置空已经访问过的值，待递归搜索出结果后再复原原先的值。
- 判断/断言的时候需要注意，是否存在重复判断。

## 解题步骤

- 针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解；
- 确定结点的扩展搜索规则；
- 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

## 业务适用场景

- 用于断言是否适合

## 引用

- [史上最全的五大算法总结](https://www.jianshu.com/p/4abfd96d91e6)
- [回溯法思路](https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban)