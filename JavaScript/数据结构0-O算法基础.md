# [O(n)](https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md) 算法基础

算法中的`O(n)`解析，以及一些排序的比较。

## 算法O(n)图像

![算法复杂度O(n)走势图](https://raw.githubusercontent.com/trekhleb/javascript-algorithms/master/assets/big-o-graph.png)

- `O(n)`描述的都是最差的那种情况，也即是可能性的最大值。最大范围。
- `Operations`：代表程序需要操作的次数。
- `Element`：代表需要操作的`数据个数(数据的长度)`
- 某些算法，操作同一数组（基本数据结构）需要不同的次数，但结果相同。研究算法就是研究在固定`Element`的情况下，如何减少`Operations`
- 复杂度的排序`O(1)` `<` `O(log n)` `<` `O(n)` `<` `O(n log n)` `<` `O(n^2)` `<` `O(2^N)` `<` `O(n!)`
- `O(n!)`、`O(2^n)`、`O(n^2)`：这三个的上升趋势很大，需要特别留意。
- 随机性：也即是 `O(n)`,随机性比较强的意思是`O(1)`

## 数据结构操作的复杂性

| 数据结构   | 链接   | 查找   | 插入   | 删除   | 备注                                 |
| :--------- | :----- | :----- | :----- | :----- | :----------------------------------- |
| 数组       | 1      | n      | n      | n      |                                      |
| 栈         | n      | n      | n      | n      |                                      |
| 队列       | n      | n      | n      | n      |                                      |
| 链表       | n      | n      | n      | n      |                                      |
| 哈希表     | -      | n      | n      | n      | 在完全哈希函数情况下，复杂度是 O(1） |
| 二分查找树 | n      | n      | n      | n      | 在平衡树情况下，复杂度是 O(log(n))   |
| B树        | log(n) | log(n) | log(n) | log(n) |                                      |
| 红黑树     | log(n) | log(n) | log(n) | log(n) |                                      |
| AVL树      | log(n) | log(n) | log(n) | log(n) |                                      |
| 布隆过滤器 | -      | 1      | 1      | -      | 存在一定概率的判断错误（误判成存在） |

- 结合上面的复杂度分析可知`log(n)` `<` `n`
- `B树`、`红黑树`、`AVL树`是一个性能很好的数据结构，
- `数组`的链接是`1`，也决定了`数组`相对于`栈`、`队列`、`链表`更优。
- `二分查找树`：在平衡树的情况下复杂度是`log(n)`。如果是`平衡树的二分查找树`，`查找、插入、删除`更优于`数组`。
- 这些要看业务的需求来衡量。


## 数组排序算法的复杂性

由上面看到，`数组`是所有基本数据结构中最为重要的数据结构。数组是有顺序的结构，那么`排序操作`就很重要了。

| 名称     | 最优    | 平均           | 最坏        | 内存   | 稳定 | 备注                                           |
| :------- | :------ | :------------- | :---------- | :----- | :--- | :--------------------------------------------- |
| 冒泡排序 | n       | n^2            | n^2         | 1      | yes  |                                                |
| 插入排序 | n       | n^2            | n^2         | 1      | yes  |                                                |
| 选择排序 | n^2     | n^2            | n^2         | 1      | no   |                                                |
| 堆排序   | nlog(n) | nlog(n)        | nlog(n)     | 1      | no   |                                                |
| 归并排序 | nlog(n) | nlog(n)        | nlog(n)     | n      | yes  |                                                |
| 快速排序 | nlog(n) | nlog(n)        | n^2         | log(n) | no   | 在 in-place 版本下，内存复杂度通常是 O(log(n)) |
| 希尔排序 | nlog(n) | 取决于差距序列 | n(log(n))^2 | 1      | no   |                                                |
| 计数排序 | n + r   | n + r          | n + r       | n + r  | yes  | r - 数组里最大的数                             |
| 基数排序 | n * k   | n * k          | n * k       | n * k  | yes  | k - 最长 key 的升序                            |

- 由复杂度优先`n` `<` `nlog(n)` `<` `n^2`
- 最优的情况下使用`冒泡排序`和`插入排序`，因为复杂度为`n`，要注意`选择排序`是`n^2`
- 在平均和最坏的情况下，选择`堆排序`和`归并排序`，但是`归并排序`比较占内存。`归并排序`占内存`n`，且稳定。
- `选择排序`需要操作的复杂度很大且不稳定，但是内存花销少。
- 为什么内存是1？有个操作叫`循环迭代赋值递归`，也即上一次的值赋值给下一次。
- 排序基本需要`循环`的操作。我们为了减少内存的花销，一般用到一个技巧叫`迭代赋值`。每一个循环，更新变量；或者释放占用内存的变量。有必要甚至用到`递归`。